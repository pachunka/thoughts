// Generated by CoffeeScript 2.5.1
(function() {
  // This is a very incomplete proof of concept. Have fun!
  var OK, client_web3, configActual, datesplitter, declareNewPost, ender, hanandle, modfs, modhttp, modos, modpath, modw3, modw3s, probably_shut_it_down, securitybreach, seriously, shut_it_down, sys_pending_shutdown, volumesplitter, w3s, wayout, web3;

  modw3 = require('web3');

  modw3s = require('web3.storage');

  modfs = require('fs');

  modos = require('os');

  modpath = require('path');

  modhttp = require('http');

  configActual = JSON.parse(String(modfs.readFileSync("CONFIGME.json")));

  securitybreach = true;

  datesplitter = 1000 * 60 * 60 * 24 * 30;

  volumesplitter = 128;

  if (!configActual["web3storage-api-key"]) {
    throw new Error("Drop your web3.storage API key into CONFIGME.json to get started.");
  }

  w3s = new modw3s.Web3Storage({
    token: configActual["web3storage-api-key"]
  });

  web3 = new modw3();

  //client_web3 = "https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"
  //client_web3 = "https://bafybeic3siupzfwsrnl2zbrwaxwm22egf6o74jsfqgw32y7vczvxf2lf6m.ipfs.dweb.link/ethers.js"
  //client_web3 = "https://cdn.jsdelivr.net/npm/web3@1.5.1/dist/web3.min.js"
  client_web3 = "https://bafybeibyqta32y3tpcrn6z7suf6dpwgt3saw6kwkal2pfbqo4hteqztoqm.ipfs.dweb.link/web3.js";

  // testing
  queueMicrotask(function() {});

  // helpers
  //console.log "Let's have a look",Object.keys(modw3)
  //lst = await  w3s.list({maxResults:10})
  //`for await (const item of lst) {`
  //chk = await item
  //console.log "Maybe",chk
  //`}`
  OK = {
    attr: function(ss) {
      return String(ss).replace(/&/g, '&#x26;').replace(/'/g, '&#x27;').replace(/"/g, '&#x22;');
    },
    html: function(ss) {
      return String(ss).replace(/&/g, '&#x26;').replace(/</g, '&#x3C;');
    }
  };

  ender = function(res, code, more) {
    res.writeHead(code, {
      'Content-Type': 'text/plain',
      'Access-Control-Allow-Origin': '*'
    });
    res.write(`${code}\n`);
    if (more) {
      res.write(`\n${more}\n`);
    }
    return res.end();
  };

  console.log(["         -= Thought Server on " + modos.hostname() + " =-         "]);

  declareNewPost = function(type, addr, cid, ocb) {
    var fn, step2;
    if (addr.match(/\./)) {
      throw new Error(`Filename compromised: ${addr}`);
    }
    if (addr.match(/[^a-zA-Z0-9]/)) {
      throw new Error(`CID compromised: ${cid}`);
    }
    fn = `db/${addr}.sw`;
    
    //console.log "yay new post for",addr,"-",cid,"\\o/"
    step2 = function(initial) {};
    
    return modfs.readFile(fn, function(er, stored) {
      var initial, lines, modified;
      initial = null;
      if (er) {
        switch (er.code) {
          case 'ENOENT':
            // brand new file
            initial = '';
            break;
          default:
            console.error(er);
            if (typeof ocb === "function") {
              ocb(false);
            }
            throw new Error(`File access problems on ${fn}`);
        }
      } else {
        initial = String(stored);
      }
      
      // step 2
      lines = initial.split('\n');
      lines.unshift(`/post ${cid}`);
      modified = lines.join('\n');
      
      return modfs.writeFile(fn, modified, function(er) {
        if (er) {
          console.error("Writing problems", er);
          if (typeof ocb === "function") {
            ocb(false);
          }
          throw new Error(`Saving is Broken: ${fn}`);
        }
        return typeof ocb === "function" ? ocb(true) : void 0;
      });
    });
  };

  // actual
  modhttp.createServer(hanandle = function(req, res) {
    var _, addr, bad, fn, gather, match, pth, rp, siggy, ttl;
    if (req.url.match(/\.\./)) { // no dot-dot requests, anywhere
      return ender(res, 400, '..');
    }
    rp = decodeURI(req.url);
    
    rp = rp.split('?')[0];
    if (rp.match(/\/$/)) {
      rp = `${rp}index.html`;
    }
    
    pth = rp.split('/');
    pth = pth.map(function(ss) {
      return ss.toLowerCase();
    });
    console.log(pth);
    if (pth[0]) {
      return ender(res, 400, "Peculiar path.");
    }
    
    if (req.method === 'PUT') {
      if (!(match = rp.match(/^\/post\/0x([0-9A-Fa-f]{40})\/0x([0-9A-Fa-f]{130})$/))) {
        console.log(rp, "ain't puttable.");
        return ender(res, 405, "Put the sword away.");
      }
      [_, addr, siggy] = match;
      
      ttl = 0;
      gather = [];
      bad = false;
      req.on('data', function(intake) {
        if (bad) {
          if (ttl > 0x4000) {
            req.connection.destroy();
          }
          return;
        }
        gather.push(String(intake));
        ttl += intake.length;
        if (ttl > 0x400) {
          return bad = true;
        }
      });
      //req.pipe ws
      req.on('end', async function() {
        var bdy, ee, said, sif, signer, thf;
        if (bad) {
          return ender(res, 413, "tl;dw");
        }
        bdy = gather.join('');
        console.log(`Happily received ${addr}, and`, bdy);
        try {
          
          signer = web3.eth.accounts.recover(bdy, "0x" + siggy);
        } catch (error) {
          ee = error;
          console.warn("web3 hates it:", siggy);
          return ender(res, 400, "Dubious signature error.");
        }
        console.log(signer, "vs.", addr);
        if (signer.toLowerCase() !== "0x" + addr.toLowerCase()) {
          console.log("IMPOSTOR");
          return ender(res, 401, "Sloppy signature error.");
        }
        //else
        console.log("All Clear");
        
        thf = new modw3s.File([bdy], "thought.txt");
        sif = new modw3s.File([
          JSON.stringify({
            eth: addr,
            sig: siggy
          })
        ], "verify.json");
        console.log("Here it goes..");
        said = false;
        try {
          await w3s.put([thf, sif], {
            name: `Thought from ${addr}`,
            onRootCidReady: function(cid) {
              return declareNewPost('post', addr, cid);
            }
          });
          //onStoredChunk: ->
          return ender(res, 204, "");
        } catch (error) {
          ee = error;
          console.warn("Upload likely didn't happen. declareNewPost was called prematurely.", ee);
          return ender(res(502, "Upload was not possible."));
        }
      });
      return;
    }
    
    if (pth[1] === ".well-known") { // add more of these if you want traditional file passthrough serving
      modfs.readFile(rp, function(er, cn) {
        if (er) {
          switch (er.code) {
            case 'ENOENT':
              console.log(req.connection.remoteAddress, "404'd", rp);
              return ender(res, 404);
            default:
              console.log(req.connection.remoteAddress, "500'd", rp);
              return ender(res, 500, er.code);
          }
        }
        res.writeHead(200, {
          'Content-Type': 'application/octet-stream',
          'Cache-Control': `max-age=${0}`
        });
        res.write(cn);
        return res.end();
      });
      return;
    } else if (pth.length === 2 && pth[1] === 'index.html') {
      res.writeHead(200, {
        'Content-Type': 'text/html',
        'Cache-Control': `max-age=${0}`,
        'Access-Control-Allow-Origin': '*'
      });
      res.write(`<!doctype html>
<meta charset=utf-8>
<style>
:root { font:medium sans-serif }
</style>
<script src="${OK.attr(client_web3)}"></script>
Anything posted here will live on IPFS forever.
<br><br>
<input type=button value="Connect Wallet" onclick="
	ethereum.request({ method: 'eth_requestAccounts' }).then(offerPostAs)
">
<script>
var web3 = new Web3(ethereum);
function attrOK (ss) {
	return String(ss).replace(/&/g, '&#x26;').replace(/'/g, '&#x27;').replace(/"/g, '&#x22;');
}
function offerPostAs (addr) {
	document.body.innerHTML = \`
		<textarea autofocus></textarea>
		<br>
		<input addr="\${ attrOK(addr) }" type="button" value="Post as \${ attrOK(addr) }" onclick="postAs(this.getAttribute('addr'))">
	\`
}
function postAs(addr) {
	var txt = document.querySelector('textarea').value;
	//
	//
	web3.eth.personal.sign(web3.utils.fromUtf8(txt),addr,function (err,ans) {
		if (err) throw new Error(err);
		var xh = new XMLHttpRequest;
		xh.open('put','/post/'+addr+'/'+ans);
		//
		xh.onabort = xh.onload = xh.onerror = ev => {
			console.info("EVL:",ev.type,xh.status,xh.statusText,ev);
		}
		//
		xh.send(txt);
	});
}
</script>`);
      res.end();
      return;
    } else if (pth.length === 3 && pth[1].match(/[a-z0-9]{40}/)) {
      fn = `db/${pth[1]}.sw`;
      
      modfs.readFile(fn, function(er, stored) {
        var send;
        if (er) {
          switch (er.code) {
            case 'ENOENT':
              // no such home
              return ender(res, 404, "No such number.");
            default:
              console.error("File access problems", er);
              return ender(res, 500, "Something is not right.");
          }
        }
        
        // Check it:
        send = String(stored);
        if (/[`\\<]/.test(send)) {
          console.warn("Skipped sending contents of", fn, "through text/html due to possible injection.");
          return ender(res, 503, "Apparent data corruption.");
        }
        
        // Ready to send:
        res.writeHead(200, {
          'Content-Type': 'text/html',
          'Cache-Control': `max-age=${0}`,
          'Access-Control-Allow-Origin': '*'
        });
        res.write(`<!doctype html>
<meta charset=utf-8>
<style>
:root { font:medium sans-serif }
</style>
<body>
<script>
function attrOK (ss) {
	return String(ss).replace(/&/g, '&#x26;').replace(/'/g, '&#x27;').replace(/"/g, '&#x22;');
}
//
customElements.define('ipfs-thought',class extends HTMLElement {
	constructor () {
		super();
		this.style.border = '1px solid';
		this.style.borderRadius = '4px';
		this.style.display = 'inline-block';
		this.style.margin = '1em';
		this.style.padding = '1em';
		console.log('boo')
	}
	static get observedAttributes() { return ['cid'] }
	attributeChangedCallback(nm,ol,nu) {
		console.log('yay')
		;(async () => {
			if (!/[a-zA-Z0-9]/.test(nu)) throw new Error("Bad CID:" + nu);
			let url = \`https://\${ nu }.ipfs.dweb.link/thought.txt\`;
			console.log("Gonna go get",url);
			let ftc = await fetch(url);
			let txt = await ftc.text();
			this.textContent = txt
		})();
	}
});
//
const lines = \`${send}\`.trim().split('\\n');
document.body.insertAdjacentHTML(
	 'beforeEnd'
	,lines
		.filter(ln => /^\\/post /.exec(ln))
		.map(ln => \`<ipfs-thought cid="\${ attrOK(ln.substr(6).trim()) }"></ipfs-thought>\`)
		.join('')
);
</script>`);
        return res.end();
      });
      return;
    }
    //else

    return ender(res, 400, "Not available.");
  }).listen(configActual["www-port"]);

  // auto-reload for cmd line stuff
  wayout = false;

  modfs.watch('.', function(tx, fn) {
    console.log(`Hit! "${tx}" / "${fn}" `);
    if (tx === 'change' && !wayout) {
      //(securitybreach and (fn.match(/\.js$/) or fn.match(/\.xhtml$/))) or
      if ((securitybreach && fn.match(/\bapp\.js$/)) || (fn.match(/\bbump\.uid$/))) {
        wayout = true;
        console.log('[[omw]]');
        //!!#md_save()
        return probably_shut_it_down();
      }
    }
  });

  // I feel like I'm gonna ctrl-c absent-mindedly and lose a bunch of data some time
  seriously = 0;

  process.on('SIGINT', function() {
    seriously += 1;
    switch (seriously) {
      case 1:
        return console.log("First Ctrl-C absorbed. 2 to go.");
      case 2:
        return console.log("Last Ctrl-C absorbed. Next terminates.");
      case 4:
        console.log("Impolitely terminating.");
        return process.exit(92);
      default:
        console.log("Politely terminating.");
        //!!#md_save()
        return probably_shut_it_down();
    }
  });

  sys_pending_shutdown = false;

  probably_shut_it_down = function() {
    //!!#if busy_saving
    //!!#	sys_pending_shutdown = yes
    //!!#else
    return shut_it_down();
  };

  shut_it_down = function() {
    return setTimeout(function() {
      if (seriously >= 3) {
        return process.exit(90);
      } else {
        return process.exit(99);
      }
    }, 125);
  };

}).call(this);
